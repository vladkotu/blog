#+TITLE:       Calculate statistical attributes, using Clojure reducers
#+AUTHOR:      Vladimir Kotushenko
#+EMAIL:       volodymyr.kotushenko@gmail.com
#+DATE:        2020-01-28 
#+URI:         /blog/clojure-reducers-statistics
#+KEYWORDS:    clojure, statistics, reducers, short
#+TAGS:        clojure, statistics, reducers, short
#+LANGUAGE:    en
#+OPTIONS:     H:5 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: Calculate mean value, using Clojure reducers

Being a JavaScript developer i always wanted to try how it is to be able to perform 
calculation in effective parallel way.

At first look Clojure concentrated on a Lazy calculations, however it still have
built-in tools for parallelisation, organized in reducers library.

** Calculate  average
   Lets

*** Using built-in reduce function
  #+begin_src clojure :results pp :eval never-export :exports both
    (def stats-defaults {:max Double/NEGATIVE_INFINITY
                         :min Double/POSITIVE_INFINITY
                         :sum 0})

    (defn stats-reducer [acc x]
      (cond-> acc
        (< x (:min acc)) (assoc :min x)
        (> x (:max acc)) (assoc :max x)
        :always          (update :sum #(+ x %))))

    (defn accumulator [coll]
      (reduce stats-reducer stats-defaults coll))

    (defn stats [accumulate coll]
      (let [{:keys [sum] :as stats'} (accumulate coll)]
        (-> stats'
            (assoc :mean (double (/ sum (count coll))))
            (dissoc :sum))))

    (def sample (->> #(rand-int 1000) (repeatedly 1000)))

    (stats accumulator sample)
  #+end_src

  #+RESULTS:
  : {:max 999, :min 2, :mean 502.855}

*** Using clojure.core.reducers/fold

  #+begin_src clojure :results pp :eval never-export :exports both
    (require '[clojure.core.reducers :as r])

    (defn stats-combiner
      ([] stats-defaults)
      ([a b] {:min (min (:min a) (:min b))
              :max (max (:max a) (:max b))
              :sum (+' (:sum a) (:sum b))}))

    (defn foldable-accumulator [coll]
      (r/fold stats-combiner
              stats-reducer
              coll))

    (stats foldable-accumulator (vec sample))
  #+end_src

  #+RESULTS:
  : {:min 2, :max 999, :mean 502.855}

** Benchmark
 Here is benchmark function based on [[https://github.com/hugoduncan/criterium][criterium]] library
 #+begin_src clojure :results silent :eval never-export :exports both
   (require '[criterium.core :as crit])

   (defn serial-reduce [coll] (stats accumulator coll))
   (defn parallel-fold [coll] (stats foldable-accumulator coll))

   (defn bench [f a]
     (let [result (crit/with-progress-reporting
                    (crit/quick-benchmark* #(f a) {}))]
       (crit/report-point-estimate (str (-> f meta :name)) (:mean result))
       {:fname (-> f meta :name)
        :count (count a)
        :mean  (long (* 1e9 (first (:mean result))))}))

   (def bresults
     (->> (for [step [10 1e2 1e3 1e4 1e5 5e5 1e6 5e6 1e7 2e7 3e7 4e7 1e8]]
            (for [[f wrap] [[#'serial-reduce identity]
                            [#'parallel-fold vec]]]
              (bench (wrap (repeatedly (long step) #(rand-int 1000))))))
          (mapcat doall)))
#+end_src

#+begin_src clojure :results graphics file link :dir "./images" :file "benchmark.svg" :exports both :eval never-export
  (require '[wiz.lib.data :refer [vega->svg]])

  (def bench-results
    [{:fname 'serial-reduce, :count 10, :mean 2972}
     {:fname 'parallel-fold, :count 10, :mean 2424}
     {:fname 'serial-reduce, :count 100, :mean 22215}
     {:fname 'parallel-fold, :count 100, :mean 14642}
     {:fname 'serial-reduce, :count 1000, :mean 217178}
     {:fname 'parallel-fold, :count 1000, :mean 108366}
     {:fname 'serial-reduce, :count 10000, :mean 2001453}
     {:fname 'parallel-fold, :count 10000, :mean 615702}
     {:fname 'serial-reduce, :count 100000, :mean 20545638}
     {:fname 'parallel-fold, :count 100000, :mean 5243293}
     {:fname 'serial-reduce, :count 500000, :mean 100860001}
     {:fname 'parallel-fold, :count 500000, :mean 25466363}
     {:fname 'serial-reduce, :count 1000000, :mean 203250896}
     {:fname 'parallel-fold, :count 1000000, :mean 49783874}
     {:fname 'serial-reduce, :count 5000000, :mean 1020905002}
     {:fname 'parallel-fold, :count 5000000, :mean 260565991}
     {:fname 'serial-reduce, :count 10000000, :mean 2111180501}
     {:fname 'parallel-fold, :count 10000000, :mean 538156350}
     {:fname 'serial-reduce, :count 20000000, :mean 4148491303}
     {:fname 'parallel-fold, :count 20000000, :mean 1070961274}
     {:fname 'serial-reduce, :count 30000000, :mean 6413696193}
     {:fname 'parallel-fold, :count 30000000, :mean 1575614529}
     {:fname 'serial-reduce, :count 40000000, :mean 8769748490}
     {:fname 'parallel-fold, :count 40000000, :mean 2142264682}
     {:fname 'serial-reduce, :count 100000000, :mean 20451333000}
     {:fname 'parallel-fold, :count 100000000, :mean 5415781049}])

  (vega->svg
   "benchmark"
   {:data  {:values bench-results}
    :mark  :rect
    :width 300
    :encoding
    {:x     {:field :count :type :ordinal}
     :y     {:field :mean :type :quantitative
             :scale {:type :log}}
     :color {:field :fname :type :nominal}}})
#+end_src

#+RESULTS:
[[file:images/benchmark.svg]]

#+begin_src clojure :results graphics file link :dir "./images" :file "rate-of-improvement.svg" :exports both :eval never-export
  (def rate-of-improvement
    (->> bench-results
         (partition 2)
         (map #(hash-map
                :times
                (float (/ (:mean (first %))
                          (:mean (second %))))
                :count (:count (first %))))))


  (vega->svg
   "rate-of-improvement"
   {:data {:values rate-of-improvement}
    :mark {:type :bar}
    :width 300
    :encoding
    {:x     {:field :count :type :ordinal
             :axis {:title "Collection size"}}
     :y     {:field :times :type :quantitative
             :axis {:title "Times faster"
                    :format ".2"}}}})
#+end_src

#+RESULTS:
[[file:images/rate-of-improvement.svg]]
