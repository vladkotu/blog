#+TITLE:       Calculate statistical attributes, using Clojure reducers
#+AUTHOR:      Vladimir Kotushenko
#+EMAIL:       volodymyr.kotushenko@gmail.com
#+DATE:        2020-01-28 
#+URI:         /blog/clojure-reducers-statistics
#+KEYWORDS:    clojure, statistics, reducers, short
#+TAGS:        clojure, statistics, reducers, short
#+LANGUAGE:    en
#+OPTIONS:     H:5 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: Calculate mean value, using Clojure reducers

Very short performance comparison of min, max and mean calculation on random
Numbers collection, using built-in Clojure functions vs reducers library.

 Sample data. Up to 10 millions random numbers from 0 to 1000 in Lazy Seq and Persistent Vector collections:
 #+begin_src clojure :results silent :eval never-export :exports both
   (defn make-sample [n]
     (->> #(rand-int 1000)
          (repeatedly n)))

   (def sample (make-sample 1000))
 #+end_src

** Calculate arithmetical average
  
*** Using built-in reduce function
  #+begin_src clojure :results pp :eval never-export :exports both
    (def stats-defaults {:max Double/NEGATIVE_INFINITY
                         :min Double/POSITIVE_INFINITY
                         :sum 0})

    (defn stats-reducer [acc x]
      (cond-> acc
        (< x (:min acc)) (assoc :min x)
        (> x (:max acc)) (assoc :max x)
        :always          (update :sum #(+ x %))))

    (defn accumulator [coll]
      (reduce stats-reducer stats-defaults coll))

    (defn stats [accumulate coll]
      (let [{:keys [sum] :as stats'} (accumulate coll)]
        (-> stats'
            (assoc :mean (double (/ sum (count coll))))
            (dissoc :sum))))

    (stats accumulator sample)
  #+end_src

  #+RESULTS:
  : {:max 999, :min 1, :mean 491.248}

*** Using clojure.core.reducers/fold

  #+begin_src clojure :results pp :eval never-export :exports both
    (require '[clojure.core.reducers :as r])

    (defn stats-combiner
      ([] stats-defaults)
      ([a b] {:min (min (:min a) (:min b))
              :max (max (:max a) (:max b))
              :sum (+' (:sum a) (:sum b))}))

    (defn foldable-accumulator [coll]
      (r/fold stats-combiner
              stats-reducer
              coll))

    (stats foldable-accumulator (vec sample))
  #+end_src

  #+RESULTS:
  : {:min 1, :max 999, :mean 491.248}

** Benchmark
 Here is benchmark function based on [[https://github.com/hugoduncan/criterium][criterium]] library
 #+begin_src clojure :results silent :eval never-export :exports both
   (require '[criterium.core :as crit])

   (defn serial-reduce [coll] (stats accumulator coll))
   (defn parallel-fold [coll] (stats foldable-accumulator coll))

   (defn bench [f a]
     (let [result (crit/with-progress-reporting
                    (crit/quick-benchmark* #(f a) {}))]
       (crit/report-point-estimate (str (-> f meta :name)) (:mean result))
       {:fname (-> f meta :name)
        :count (count a)
        :mean  (long (* 1e9 (first (:mean result))))}))

   (def bresults
     (->> (for [step [1e2 1e3 1e4 1e5 1e6 1e7 2e7 3e7 4e7]]
            (for [[f wrap] [[#'serial-reduce identity]
                            [#'parallel-fold vec]]]
              (bench f (wrap (make-sample (long step))))))
          (mapcat doall)))
#+end_src

#+begin_src clojure :results graphics file link :dir "./images" :file "benchmark.svg" :exports both :eval never-export
  (require '[wiz.lib.data :refer [vega->svg]])

  (defn plot [name data]
    (vega->svg
     name
     {:data {:values data}
      :mark {:type :line}
      :encoding
      {:x     {:field :count :type :quantitative}
       :y     {:field :mean  :type :quantitative}
       :color {:field :fname :type :nominal}}}))

  (plot "benchmark" bresults)
#+end_src

#+RESULTS:
[[file:images/benchmark.svg]]

#+begin_src clojure :results graphics file link :dir "./images" :file "rate-of-improvement.svg" :exports both :eval never-export
  (def rate-of-improvement
    (->> (concat  bresults r3e7 r4e7)
         (partition 2)
         (map #(hash-map
                :times
                (float (/ (:mean (first %))
                          (:mean (second %))))
                :count (:count (first %))))))

  (first rate-of-improvement)
  (vega->svg
   "rate-of-improvement"
   {:data {:values rate-of-improvement}
    :mark {:type :bar}
    :encoding
    {:x     {:field :count :type :ordinal
             :axis {:title "Collection size"}}
     :y     {:field :times :type :quantitative
             :axis {:title "Times faster"
                    :format ".2"}}}})
#+end_src

#+RESULTS:
[[file:images/rate-of-improvement.svg]]
