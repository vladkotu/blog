#+TITLE:       Data munging with SF Bay Area Bike Share
#+AUTHOR:      Vladimir Kotushenko
#+EMAIL:       volodymyr.kotushenko@gmail.com
#+DATE:        2019-11-18 
#+URI:         /blog/strings-and-characters
#+KEYWORDS:    clojure, kaggle, dataset, beginner
#+TAGS:        clojure, kaggle, dataset, beginner
#+LANGUAGE:    en
#+OPTIONS:     H:5 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: Basic data manipulation using clojure as data science tool

**** Lib imports and helpers.   
 #+NAME: imports
 #+begin_src clojure :results silent :eval never-export
   (use '[wiz.lib.data] :reload)
   (require
    '[clojure.java.io]
    '[clojure.data.csv]
    '[clojure.data.json]
    '[clojure.java.shell :as sh]
    '[semantic-csv.core :as sc]
    '[semantic-csv.transducers :as sct]
    '[huri.core :as huri]
    '[clojure.pprint :as pp]
    '[net.cgrand.xforms :as x]
    '[huri.io]
    '[oz.core]
    '[clustering.core.qt :as qt])
 #+END_SRC

**** Look at 'stations.scv' dataset
 
Extract Raw data from csv, and observe first couple rows

#+begin_src clojure :results pp :eval never-export :exports both
  (def stations-csv-path  "./data/station.csv")
  (println (:out (sh/sh "du" "-h" stations-csv-path)))
#+end_src 

#+RESULTS:
: 8.0K	./data/station.csv
: 
: nil

Read and parse './data/station.csv'
#+begin_src clojure :results pp :eval never-export :exports both
  (def stations-data
    (time
     (with-open [reader (clojure.java.io/reader stations-csv-path)]
       (->> (clojure.data.csv/read-csv reader)
            (sequence (comp (sct/remove-comments)
                            (sct/mappify)
                            (map #(clojure.set/rename-keys % {:dock_count :docks :installation_date :year}))
                            (map #(update-all % [:id :docks] sc/->int))
                            (map #(update % :year (comp  sc/->int (take-last-str 4))))))
            (doall)))))
#+END_SRC

#+RESULTS:
: "Elapsed time: 4.910676 msecs"
: #'user/stations-data

Size of dataset
#+begin_src clojure :results pp :eval never-export :exports both
  (size stations-data)
#+end_src
#+RESULTS:
: {:cols 7, :rows 70}

What columns are exists?
#+begin_src clojure :results pp :eval never-export :exports both
  (huri/cols stations-data)
#+end_src

#+RESULTS:
: (:id :name :lat :long :city :docks :year)

Preview head of table:
#+begin_src clojure :results pp :eval never-export :exports both
  (->> stations-data
       (take 5)
       (pp/print-table))
#+end_src

#+RESULTS:
: 
: | :id |                             :name |               :lat |               :long |    :city | :docks | :year |
: |-----+-----------------------------------+--------------------+---------------------+----------+--------+-------|
: |   2 | San Jose Diridon Caltrain Station |          37.329732 | -121.90178200000001 | San Jose |     27 |  2013 |
: |   3 |             San Jose Civic Center |          37.330698 |         -121.888979 | San Jose |     15 |  2013 |
: |   4 |            Santa Clara at Almaden |          37.333988 |         -121.894902 | San Jose |     11 |  2013 |
: |   5 |                  Adobe on Almaden |          37.331415 |           -121.8932 | San Jose |     19 |  2013 |
: |   6 |                  San Pedro Square | 37.336721000000004 |         -121.894074 | San Jose |     15 |  2013 |
: nil

  Set of questions taht could be targeted on that dataset:
  - How many dock station are exists in each city?
  - How many docks?
  - What is smallest/largest size of stations in a city?
  - Is there a big extent in manufacturing year on station across the city?
  #+NAME: cities
  #+begin_src clojure :results pp :exports both :eval never-export
    (def docks-by-city
      (huri/rollup-fuse
       :city {:stations     count
              :docks        [huri/sum :docks]
              :docks-extent [huri/extent :docks]
              :year-extent  [huri/extent :year]} stations-data))

    (pp/print-table docks-by-city)
  #+END_SRC

  #+RESULTS: cities
  : 
  : | :stations | :docks | :docks-extent | :year-extent |         :city |
  : |-----------+--------+---------------+--------------+---------------|
  : |         7 |    117 |       [11 23] |  [2013 2013] | Mountain View |
  : |         5 |     75 |       [11 23] |  [2013 2013] |     Palo Alto |
  : |         7 |    115 |       [15 25] |  [2013 2014] |  Redwood City |
  : |        35 |    665 |       [15 27] |  [2013 2014] | San Francisco |
  : |        16 |    264 |       [11 27] |  [2013 2014] |      San Jose |
  : nil

  Compare number of docks in a city visually:
  #+NAME: cities-bar-chart
  #+begin_src clojure :results graphics file link :dir "images/" :file "cities.svg" :exports both :eval never-export
     (def bar-chart
       {:data     {:values docks-by-city}
        :encoding {:x {:field "docks" :type "quantitative"
                       :axis  {:title "Number of stations"}}
                   :y {:field "city" :type "ordinal" :sort "-x"
                       :axis  {:title nil}}}
        :width    300
        :mark     "bar"})

    (vega->svg "cities" bar-chart)
  #+END_SRC

  #+RESULTS: cities-bar-chart
  [[file:images/cities.svg]]

                
  Where does stations located in a San Francisco city?
  #+begin_src clojure :results graphics file link :dir "images/" :file "map.svg" :exports both :eval never-export
    (def geojson (huri.io/slurp-json "./data/san-francisco.geojson"))
    (def sf-data (->> stations-data (huri/where {:city "San Francisco"})))
    (def common-layer-props
      {:width      100
       :height     100
       :projection {:type :mercator}})

    (def bubble-chart
      {:layer
       (map
        #(merge common-layer-props %)
        [{:data {:values geojson
                 :format {:propery :features}}
          :mark {:type   :geoshape
                 :fill   "#eee"
                 :stroke "#fff"}}

         {:data     {:values sf-data}
          :encoding {:latitude  {:field :lat :type :quantitative}
                     :longitude {:field :long :type :quantitative}
                     :color     {:field :city :type :nominal :title "City"}}
          :mark     :point}])})

    (vega->svg "map" bubble-chart)
  #+END_SRC

  #+RESULTS:
  [[file:images/map.svg]]
  
**** Observe 'trips.csv' dataset
#+begin_src clojure :results pp :eval never-export :exports both
  (def trip-csv-path   "./data/trip.csv")
  (println (:out (sh/sh "du" "-h" trip-csv-path)))
#+end_src

#+RESULTS:
:  76M	./data/trip.csv
: 
: nil

Read and parse 'trip.csv'
#+begin_src clojure :results pp :eval never-export :exports both
  (def trips-data
    (time
     (with-open [reader (clojure.java.io/reader trip-csv-path)]
       (->> (clojure.data.csv/read-csv reader)
            (sequence
             (comp
              (sct/remove-comments)
              (sct/mappify)
              ;; (map #(dissoc-all % [:id :zip_code :end_date :start_date]))
              (map #(update-all % [:duration :start_station_id
                                   :id :bike_id :end_station_id] sc/->int))
              (map #(update % :subscription_type ->keyw))))
            (doall)))))
#+END_SRC

  #+RESULTS:
  : "Elapsed time: 8583.398375 msecs"
  : #'user/trips-data

  Size of dataset and columns:
#+begin_src clojure :results pp :eval never-export :exports both
  (println (size trips-data))
  (huri/cols trips-data)
#+end_src

#+RESULTS:
#+begin_example
{:cols 11, :rows 669959}
(:zip_code
 :start_station_name
 :end_station_name
 :duration
 :start_station_id
 :end_date
 :start_date
 :id
 :bike_id
 :end_station_id
 :subscription_type)
#+end_example

Head of dataset
#+begin_src clojure :results pp :eval never-export :exports both
  (->> trips-data
       (sample 5)
       (pp/print-table))
#+end_src

#+RESULTS:
: 
: | :zip_code |                      :start_station_name |                       :end_station_name | :duration | :start_station_id |        :end_date |      :start_date |    :id | :bike_id | :end_station_id | :subscription_type |
: |-----------+------------------------------------------+-----------------------------------------+-----------+-------------------+------------------+------------------+--------+----------+-----------------+--------------------|
: |     94041 |                   Embarcadero at Vallejo |                  Embarcadero at Sansome |      1411 |                48 |   7/4/2015 14:59 |   7/4/2015 14:35 | 833220 |      415 |              60 |          :customer |
: |     94107 |                          2nd at Townsend |                   Embarcadero at Bryant |       282 |                61 |   8/11/2015 9:21 |   8/11/2015 9:17 | 884493 |      493 |              54 |        :subscriber |
: |     94939 | San Francisco Caltrain (Townsend at 4th) |    Harry Bridges Plaza (Ferry Building) |       695 |                70 |  2/11/2015 18:55 |  2/11/2015 18:43 | 640432 |      557 |              50 |        :subscriber |
: |     94107 |                       Powell Street BART | San Francisco Caltrain 2 (330 Townsend) |       474 |                39 | 11/11/2014 20:49 | 11/11/2014 20:41 | 540441 |       66 |              69 |        :subscriber |
: |     94306 |        San Jose Diridon Caltrain Station |                        San Pedro Square |       560 |                 2 |   1/20/2015 8:28 |   1/20/2015 8:19 | 610310 |      241 |               6 |        :subscriber |
: nil

Group trips by city buckets, trips between cities in a separate bucket
#+begin_src clojure :results pp :eval never-export :exports both
  (def city-by-station
    (memoize
     (fn city-by-station [tid]
       (:city (->> stations-data
                   (filter #(= (:id %) tid))
                   first)))))

  (defn cross-city? [trip]
    (let [start-city (city-by-station (:start_station_id trip))
          end-city   (city-by-station (:end_station_id trip))]
      (not= start-city end-city)))

  (defn city-name [trip]
    (if (cross-city? trip)
      "cross-city"
      (city-by-station (:start_station_id trip))))

  (defn group-by-cities [dt]
    (huri/rollup
     city-name
     identity
     #(if (cross-city? %)
        (-> %
            (assoc :start_city (city-by-station (:start_station_id %)))
            (assoc :end_city   (city-by-station (:end_station_id %))))
        (assoc % :city (city-by-station (:start_station_id %)))) dt))


  (def city-trips-data (time (group-by-cities trips-data)))
#+end_src

#+RESULTS:
: "Elapsed time: 977.592271 msecs"
: #'user/city-trips-data

#+begin_src clojure :results graphics file link :dir "images/" :file "fff.svg" :exports both :eval never-export
  (def stacked-bar-chart
    {:data     {:values (into []
                              (map #(hash-map :city (first %)
                                              :count (count (last %))))
                              city-trips-data)}
     :mark     :bar
     :encoding {:x     {:field :count :type :quantitative}
                :y     {:field :city :type :nominal :sort "-x" :axis nil}
                :color {:field :city :type :nominal}}})

  (vega->svg "fff" stacked-bar-chart)
#+end_src

#+RESULTS:
[[file:images/fff.svg]]


Duration of ride:
#+begin_src clojure :results graphics file link :dir "./images" :file "sf-durations.svg" :exports both :eval never-export
  (def sf-city-data (get city-trips-data "San Francisco"))

  (huri/extent :duration sf-city-data)

  (oz.core/start-server!)

  (def duration-data
    (time (->> sf-city-data
               (map :duration)
               (partitions 10000)
               (map huri/mean)
               (map int)
               (frequencies)
               (map #(hash-map :data (first %)
                               :count (second %))))))

  (def partitions-num-chart
    {:data     {:values duration-data}
     :width    800
     :mark     :tick
     :encoding {:x {:field :data :type :quantitative
                    :scale {:type :log}}
                :y {:field :count :type :quantitative}
                }})

  (oz.core/view! partitions-num-chart)

  (def duration-chart
    {:data {:values duration-data}
     ;; :width {:step 16}
     :width 500
     ;; :mark {:type :bar :bin-spacing 0}
     :mark :tick
     :encoding {:x {:field :duration :type :quantitative
                    ;; :bin true
                    }
                ;; :y {:field :count :type :quantitative}
                }})

  ;; (time (vega->svg "sf-durations" duration-chart))


  (oz.core/view! duration-chart)
#+end_src


