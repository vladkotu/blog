#+TITLE:       Data munging with SF Bay Area Bike Share
#+AUTHOR:      Vladimir Kotushenko
#+EMAIL:       volodymyr.kotushenko@gmail.com
#+DATE:        2019-11-18 
#+URI:         /blog/strings-and-characters
#+KEYWORDS:    clojure, kaggle, dataset, beginner
#+TAGS:        clojure, kaggle, dataset, beginner
#+LANGUAGE:    en
#+OPTIONS:     H:5 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: Basic data manipulation using clojure as data science tool

**** Lib imports and helpers.   
 #+NAME: imports
 #+begin_src clojure :results silent :eval never-export
   (use '[wiz.lib.data] :reload)
   (require '[clojure.java.io]
            '[clojure.data.csv]
            '[clojure.data.json]
            '[clojure.java.shell :as sh]
            '[semantic-csv.core :as sc]
            '[semantic-csv.transducers :as sct]
            '[huri.core :as huri]
            '[clojure.pprint :as pp]
            '[net.cgrand.xforms :as x])

   (defn export-vega-csv
     "helper function convert clj vega spec to json and store it as tmp file"
     [fname content]
     (let [tmp-file (java.io.File/createTempFile "tmp." ".json")]
       (.deleteOnExit tmp-file)
       (with-open [writer (clojure.java.io/writer tmp-file)]
         (clojure.data.json/write content writer))
       (let [source (.getAbsolutePath tmp-file)
             dest   (str "./images/" fname ".svg")]
         (sh/sh "vl2svg" source dest))))
 #+END_SRC

**** Look at 'stations.scv' dataset
 
Extract Raw data from csv, and observe first couple rows

#+begin_src clojure :results pp :eval never-export :exports both
  (def stations-csv-path  "./data/station.csv")
  (println (:out (sh/sh "du" "-h" stations-csv-path)))
#+end_src 

#+RESULTS:
: 8.0K	./data/station.csv
: 
: nil

Read and parse './data/station.csv'
#+begin_src clojure :results pp :eval never-export :exports both
  (def stations-data
    (time
     (with-open [reader (clojure.java.io/reader stations-csv-path)]
       (->> (clojure.data.csv/read-csv reader)
            (sequence (comp (sct/remove-comments)
                            (sct/mappify)
                            ;; (map #(dissoc-all % [:id]))
                            (map #(clojure.set/rename-keys % {:dock_count :docks :installation_date :year}))
                            (map #(update % :docks sc/->int))
                            (map #(update % :id sc/->int))
                            (map #(update % :year (comp  sc/->int (take-last-str 4))))))
            (doall)))))
#+END_SRC

#+RESULTS:
: "Elapsed time: 7.978763 msecs"
: #'user/stations-data

Size of dataset
#+begin_src clojure :results pp :eval never-export :exports both
  (size stations-data)
#+end_src
#+RESULTS:
: {:cols 7, :rows 70}

What columns are exists?
#+begin_src clojure :results pp :eval never-export :exports both
  (huri/cols stations-data)
#+end_src

#+RESULTS:
: (:id :name :lat :long :city :docks :year)

Preview head of table:
#+begin_src clojure :results pp :eval never-export :exports both
  (->> stations-data
       (take 5)
       (pp/print-table))
#+end_src

#+RESULTS:
: 
: | :id |                             :name |               :lat |               :long |    :city | :docks | :year |
: |-----+-----------------------------------+--------------------+---------------------+----------+--------+-------|
: |   2 | San Jose Diridon Caltrain Station |          37.329732 | -121.90178200000001 | San Jose |     27 |  2013 |
: |   3 |             San Jose Civic Center |          37.330698 |         -121.888979 | San Jose |     15 |  2013 |
: |   4 |            Santa Clara at Almaden |          37.333988 |         -121.894902 | San Jose |     11 |  2013 |
: |   5 |                  Adobe on Almaden |          37.331415 |           -121.8932 | San Jose |     19 |  2013 |
: |   6 |                  San Pedro Square | 37.336721000000004 |         -121.894074 | San Jose |     15 |  2013 |
: nil


  Set of questions taht could be targeted on that dataset:
  - How many dock station are exists in each city?
  - How many docks?
  - What is smallest/largest size of stations in a city?
  - Is there a big extent in manufacturing year on station across the city?
  #+NAME: cities
  #+begin_src clojure :results pp :exports both :eval never-export
    (def docks-by-city
      (huri/rollup-fuse
       :city {:stations     count
              :docks        [huri/sum :docks]
              :docks-extent [huri/extent :docks]
              :year-extent  [huri/extent :year]} stations-data))

    (pp/print-table docks-by-city)
  #+END_SRC

  #+RESULTS: cities
  : 
  : | :stations | :docks | :docks-extent | :year-extent |         :city |
  : |-----------+--------+---------------+--------------+---------------|
  : |         7 |    117 |       [11 23] |  [2013 2013] | Mountain View |
  : |         5 |     75 |       [11 23] |  [2013 2013] |     Palo Alto |
  : |         7 |    115 |       [15 25] |  [2013 2014] |  Redwood City |
  : |        35 |    665 |       [15 27] |  [2013 2014] | San Francisco |
  : |        16 |    264 |       [11 27] |  [2013 2014] |      San Jose |
  : nil

  Compare number of docks in a city visually:
  #+NAME: cities-bar-chart
  #+begin_src clojure :results graphics file link :dir "images/" :file "cities.svg" :exports both :eval never-export
     (def bar-chart
       {:data     {:values docks-by-city}
        :encoding {:x {:field "docks" :type "quantitative"
                       :axis  {:title "Number of stations"}}
                   :y {:field "city" :type "ordinal" :sort "-x"
                       :axis  {:title nil}}}
        :width    300
        :mark     "bar"})

    (export-vega-csv "cities" bar-chart)
  #+END_SRC

  #+RESULTS: cities-bar-chart
  [[file:images/cities.svg]]

                
  Where does stations located in a San Francisco city?
  #+begin_src clojure :results graphics file link :dir "images/" :file "map.svg" :exports both :eval never-export
    (def geojson (huri.io/slurp-json "./data/san-francisco.geojson"))
    (def sf-data (->> stations-data (huri/where {:city "San Francisco"})))
    (def common-layer-props
      {:width      100
       :height     100
       :projection {:type :mercator}})

    (def bubble-chart
      {:layer
       (map
        #(merge common-layer-props %)
        [{:data {:values geojson
                 :format {:propery :features}}
          :mark {:type   :geoshape
                 :fill   "#eee"
                 :stroke "#fff"}}

         {:data     {:values sf-data}
          :encoding {:latitude  {:field :lat :type :quantitative}
                     :longitude {:field :long :type :quantitative}
                     :color     {:field :city :type :nominal :title "City"}}
          :mark     :point}])})

    (export-vega-csv "map" bubble-chart)
  #+END_SRC

  #+RESULTS:
  [[file:images/map.svg]]
  
**** Observe 'trips.csv' dataset
#+begin_src clojure :results pp :eval never-export :exports both
  (def trip-csv-path   "./data/trip.csv")
  (println (:out (sh/sh "du" "-h" trip-csv-path)))
#+end_src

#+RESULTS:
:  76M	./data/trip.csv
: 
: nil

Read and parse 'trip.csv'
#+begin_src clojure :results pp :eval never-export :exports both
  (def trips-data
    (time
     (with-open [reader (clojure.java.io/reader trip-csv-path)]
       (->> (clojure.data.csv/read-csv reader)
            (sequence
             (comp
              (sct/remove-comments)
              (sct/mappify)
              (map #(dissoc-all % [:id :zip-code :end_date :start_date]))
              (map #(update-all % [:duration :start_station_id
                                   :id :bike_id :end_station_id] sc/->int))
              (map #(update % :subscription_type ->keyw))))
            (doall)))))
#+END_SRC

  #+RESULTS:
  : "Elapsed time: 7420.453026 msecs"
  : #'user/trips-data

  Size of datasets and columns:
#+begin_src clojure :results pp :eval never-export :exports both
  (println (size trips-data))
  (huri/cols trips-data)
#+end_src

#+RESULTS:
#+begin_example
{:cols 9, :rows 669959}
(:zip_code
 :start_station_name
 :end_station_name
 :duration
 :start_station_id
 :id
 :bike_id
 :end_station_id
 :subscription_type)
#+end_example

Head of dataset
#+begin_src clojure :results pp :eval never-export :exports both
  (->> trips-data
       (sample 5)
       (pp/print-table))
#+end_src

#+RESULTS:
: 
: | :zip_code |             :start_station_name |                       :end_station_name | :duration | :start_station_id | :id | :bike_id | :end_station_id | :subscription_type |
: |-----------+---------------------------------+-----------------------------------------+-----------+-------------------+-----+----------+-----------------+--------------------|
: |           |                 2nd at Townsend |                         2nd at Townsend |       667 |                61 |     |      469 |              61 |          :customer |
: |     94133 |                 Beale at Market |                           Market at 4th |       420 |                56 |     |      450 |              76 |        :subscriber |
: |      3783 | Grant Avenue at Columbus Avenue |           Powell at Post (Union Square) |      2304 |                73 |     |      355 |              71 |          :customer |
: |     33131 |            Washington at Kearny |                           Howard at 2nd |       491 |                46 |     |      290 |              63 |          :customer |
: |     94107 |                   Market at 4th | San Francisco Caltrain 2 (330 Townsend) |       419 |                76 |     |      439 |              69 |        :subscriber |
: nil

Group trips by city buckets, trips between cities in a separate bucket
#+begin_src clojure :results pp :eval never-export :exports both
  (def city-by-station
    (memoize
     (fn city-by-station [tid]
       (:city (->> stations-data
                   (filter #(= (:id %) tid))
                   first)))))

  (defn cross-city? [trip]
    (let [start-city (city-by-station (:start_station_id trip))
          end-city   (city-by-station (:end_station_id trip))]
      (not= start-city end-city)))

  (defn city-name [trip]
    (if (cross-city? trip)
      "cross-city"
      (city-by-station (:start_station_id trip))))

  (defn group-by-cities [dt]
    (huri/rollup
     city-name
     identity
     #(if (cross-city? %)
        (-> %
            (assoc :start_city (city-by-station (:start_station_id %)))
            (assoc :end_city   (city-by-station (:end_station_id %))))
        (assoc % :city (city-by-station (:start_station_id %)))) dt))

  (def city-trips-data (time (group-by-cities trips-data)))
#+end_src

#+RESULTS:
: "Elapsed time: 885.13596 msecs"
: #'user/city-trips-data

#+begin_src clojure :results graphics file link :dir "images/" :file "trips-by-city.svg" :exports both :eval never-export
  (def stacked-bar-chart
    {:data     {:values (into []
                              (map #(hash-map :city (first %)
                                              :count (count (last %))))
                              city-trips-data)}
     :mark     :bar
     :encoding {:x     {:field :count :type :quantitative}
                :y     {:field :city :type :nominal :sort "-x" :axis nil}
                :color {:field :city :type :nominal}}})

  (vega->svg "trips-by-city" stacked-bar-chart)
#+end_src

#+RESULTS:
[[file:images/trips-by-city.svg]]


Duration of ride:
#+begin_src clojure :results graphics file link :dir "./images" :file "sf-durations.svg" :exports both :eval never-export
  (def sf-city-data (get city-trips-data "San Francisco"))

  (def duration-data
    (->> sf-city-data
         (map :duration)
         (partitions 10000)
         (map huri/mean)
         (map int)
         (frequencies)
         (map #(hash-map :data (first %)
                         :count (second %)))))

  (def partitions-num-chart
    {:data     {:values duration-data}
     :width    800
     :mark     :tick
     :encoding {:x {:field :data :type :quantitative
                    :scale {:type :log}}
                :y {:field :count :type :quantitative}}})

  (def duration-chart
    {:data {:values duration-data}
     ;; :width {:step 16}
     :width 500
     ;; :mark {:type :bar :bin-spacing 0}
     :mark :tick
     :encoding {:x {:field :duration :type :quantitative
                    ;; :bin true
                    }
                ;; :y {:field :count :type :quantitative}
                }})

  (export-vega-csv "sf-durations" duration-chart)
#+end_src

#+RESULTS:
[[file:images/sf-durations.svg]]

