* Destructuring pattern in clojure

** Rest operator

Most often it's being used to destructure args list to first and rest items
#+NAME: first-rest
#+begin_src clojure :results pp :eval never-export
  (defn foo [a-first & a-rest]
    [a-first a-rest])

  (foo :first :second :third)
  ;; => [:first (:second :third)]
#+END_SRC

It also could be used in a ~let~ binding:
#+NAME: f-r-let
#+begin_src clojure :results pp :eval never-export
  (let [[f & rs] [1 2 3]]
    [f rs])
  ;; => [1 (2 3)]
#+END_SRC

Rest operator could be solo used as well (that what you did in your example):
#+NAME: solo-rest
#+begin_src clojure :results pp :eval never-export
  (defn two-fer [& name]
    name)

  (two-fer)
  ;; => nil
  (two-fer "name")
  ;; => ("name")
  (two-fer "name 1" "name 2")
  ;; => ("name 1" "name 2")
#+END_SRC
so you can see reurning type here would be sequence:
#+NAME: list-or-not
#+begin_src clojure :results pp :eval never-export
  (type (two-fer "name"))
  ;; => clojure.lang.ArraySeq
#+END_SRC

than you've passed it down to ~format~ end it will try to coerce it to string,
as ~%s~ instruction states
#+NAME: list-to-str
#+begin_src clojure :results pp :eval never-export

#+END_SRC
